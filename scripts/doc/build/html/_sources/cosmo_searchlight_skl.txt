.. cosmo_searchlight_skl

cosmo searchlight skl
=====================
.. code-block:: matlab

    function results_map = cosmo_searchlight(dataset, measure, varargin)
    %  Generic searchlight function returns a map of results computed at each
    %  searchlight location 
    %   
<<<<<<< HEAD
    %   results_map=cosmo_searchlight(dataset, measure, [args, radius])
=======
    %   results_map=cosmo_searchlight(dataset, measure, ['args',args]['radius',radius],['center_ids',center_ids])
>>>>>>> c4b519d40110aed8222949935d9bb74bb8c5de26
    %
    %   Inputs
    %       dataset: an instance of a cosmo_fmri_dataset
    %       measure: a function handle to a dataset measure. A dataset measure has
    %               the function signature: output = measure(dataset, args)
    %       args:   a struct that contains all the fields necessary to the dataset
    %               measure. args get passed directly to the dataset measure.
<<<<<<< HEAD
=======
    %       center_ids: vector indicating center ids to be used as a 
    %                        searchlight center. By default all feature ids are
    %                        used
    %       radius: searchlight radius in voxels (default: 3)
>>>>>>> c4b519d40110aed8222949935d9bb74bb8c5de26
    %
    %   Returns
    %       results_map:    an instance of a cosmo_fmri_dataset where the samples
    %                       contain the results of the searchlight analysis.
    % 
    %   Example: Using the searchlight to compute a full-brain nearest neighbor
    %               classification searchlight with n-fold cross validation:
    %
    %       ds = cosmo_fmri_dataset('data.nii.gz','mask','brain_mask.nii.gz', ...
    %                                'targets',targets,'chunks',chunks);
    %       cv = @cosmo_cross_validate;
    %       cv_args = struct();
    %       cv_args.classifier = @cosmo_classify_nn;
    %       cv_args.partitions = cosmo_nfold_partitioner(ds.sa.chunks);
    %       results = cosmo_searchlight(ds,cv,cv_args);     
    %       
    %       
    % ACC Aug 2013, modified from run_voxel_selection_searchlight by NN0
    
<<<<<<< HEAD
        parser = inputParser;
        addOptional(parser,'radius',3);
=======
        nfeatures=size(dataset.samples,2);
    
        parser = inputParser;
        addOptional(parser,'radius',3);
        addOptional(parser,'center_ids',1:nfeatures);
>>>>>>> c4b519d40110aed8222949935d9bb74bb8c5de26
        addOptional(parser,'args',struct());
        parse(parser,varargin{:});
        p = parser.Results;
        radius = p.radius;
        args = p.args;
<<<<<<< HEAD
    
        
        % 
        nfeatures=size(dataset.samples,2);
        center_ids=1:nfeatures; % for now, consider all voxels
=======
        center_ids=p.center_ids;
>>>>>>> c4b519d40110aed8222949935d9bb74bb8c5de26
    
        % use voxel selection function
        center2neighbors=cosmo_spherical_voxel_selection(dataset, radius, center_ids);
    
        % space for output, we will leave res empty for now because we can't know
<<<<<<< HEAD
        % yet the size of the array returned by our dtaset measure.
        ncenters=numel(center_ids);
        res=[];
    
        % go over all features, run cross-validation and store the classiifcation
        % accuracies.
        % [your code here]
    
        % store the output
        results_map=dataset;
=======
        % yet the size of the array returned by our dtaset measure. Instead 
        % space will be allocated after the first times the measure is used. 
        ncenters=numel(center_ids);
        res=[];
    
        % go over all features; for each feature, apply the measure and 
        % store its output.
        %%%% >>> YOUR CODE HERE <<< %%%%
    
        % store the output in a dataset
        results_map=cosmo_dataset_slice_features(dataset, center_ids);
>>>>>>> c4b519d40110aed8222949935d9bb74bb8c5de26
        results_map.samples=res;
    
    